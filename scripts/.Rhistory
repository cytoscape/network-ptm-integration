# for (l in suids){
#   ptms <- rbind(ptms, l)
# }
##Set node position bypass for ptm nodes. Use 4 sites on each node.
pos <- 1
#for (ptm in phospho.nodes$comp_id){
for (ptm in ptms$SUID){
addCyEdges(c(p, ptm)) #need the SUID for this
x <- subset(phospho.positions, position == pos)$x
y <- subset(phospho.positions, position == pos)$y
print(x)
print(y)
setNodePositionBypass(ptm, x, y)
pos <- pos+1
}
ptms.all <- rbind(ptms.all, ptms)
}
loadTableData(cptac.protein,data.key.column="symbol", "node", table.key.column = 'shared name')
RCy3::setNodeColorMapping('CCRCC.pval', colors=paletteColorBrewerBlues(), style.name = style.name)
RCy3::setNodeColorMapping('CCRCC.pval', colors=paletteColorBrewerBlues)
##############
## Data viz
style.name = "WikiPathways"
RCy3::setNodeColorMapping('CCRCC.pval', colors=paletteColorBrewerBlues, style.name = style.name)
setNodeColorDefault('#FFFFFF', style.name = style.name)
## Update style for ptm nodes.
setNodeFontSizeBypass(ptms.all$SUID, 9)
setNodeWidthBypass(ptms.all$SUID, 40)
setNodeHeightBypass(ptms.all$SUID, 20)
View(ptms.all)
View(cptac.phospho.ccrcc.sig)
###############
## Open and process WP, get relevant phospho data nodes and cross-check against kinase-substrate data
RCy3::commandsRun('wikipathways import-as-pathway id=WP4806')
## Remove existing ptm states from nodes. These are encoded as nodes with the label P.
selectNodes(nodes = "p", by.col = "name", preserve.current.selection = FALSE)
deleteSelectedNodes()
mode <- "all"
## Get all relevant protein/gene product data nodes in pathway
node.table <- RCy3::getTableColumns(table = "node")
node.table.prot <- subset(node.table, Type == 'Protein' | Type == 'GeneProduct') %>%
select(SUID, name, XrefId, Ensembl) ##get node table entries for relevant nodes
## All matching nodes: Intersection between pathway protein/gene nodes and phospho data
## These are the nodes we are going to add phospho nodes to
matching.nodes.prot <- node.table.prot %>%
filter(name %in% cptac.phospho.ccrcc.sig$symbol) %>%
select(SUID, name)
## Need this for matching with kinase substrate data
matching.nodes.phospho <- cptac.phospho.ccrcc.sig %>%
filter(symbol %in% node.table.prot$name) %>%
mutate(comp_id=paste0(symbol, "_", site)) %>%
select(symbol, site, comp_id, CCRCC.val, CCRCC.pval)
###############
## Only those sites with kinases on pathway: Subset of matching nodes with relevant kinases in the pathway
## To-Do: need to refactor for alt strategy
kinase.pw <- intersect(psp.data.human$GENE, node.table.prot$name) #Kinases on pathway. GENE column contains kinase.
## Overlap between phospho nodes and kinase-substrate data, where the kinase (GENE) is on the pathway
phospho.psp.kin <- inner_join(matching.nodes.phospho, psp.data.human) %>%
filter(GENE %in% kinase.pw)
phospho.psp.kin.sites <- phospho.psp.kin %>%
select(symbol, comp_id, CCRCC.val, CCRCC.pval)
phospho.psp.kin.sites <- distinct(phospho.psp.kin.sites)
site.table <- matching.nodes.phospho
## If mode is "kinase only", update inputs
if (mode == "kinase"){
site.table <- phospho.psp.kin.sites
}
ptms.all <- data.frame()
for (p in matching.nodes.prot$SUID){
prot <- matching.nodes.prot$name[matching.nodes.prot$SUID == p]
#Get node position for protein node
p.position <- getNodePosition(node.names = p)
#Calculate possible phospho site positions, limit to 4 sites for now.
phospho.positions <- data.frame()
pos.x <- p.position$x_location
pos.y <- p.position$y_location
phospho.positions <- data.frame(position=1:4, x=c(pos.x+30, pos.x+30, pos.x-30, pos.x-30), y=c(pos.y+10, pos.y-10, pos.y-10, pos.y+10))
#find relevant subset of cptac phospho data, these are the ptm nodes to add
phospho.nodes <- site.table %>%
filter(symbol == prot) %>%
select(comp_id)
print(phospho.nodes)
phospho.nodes <- head(phospho.nodes, 4) ##take first 4
##Add a node for each ptm, for the particular protein. Collect the SUID for the added ptm, and use it for updating position below.
suids <- addCyNodes(node.names = phospho.nodes$comp_id, skip.duplicate.names = FALSE)
ptms <- data.frame()
# ptms <- do.call(rbind, suids) doesnt work
for (l in suids){
ptms <- rbind(ptms, l)
}
##Set node position bypass for ptm nodes. Use 4 sites on each node.
pos <- 1
#for (ptm in phospho.nodes$comp_id){
for (ptm in ptms$SUID){
addCyEdges(c(p, ptm)) #need the SUID for this
x <- subset(phospho.positions, position == pos)$x
y <- subset(phospho.positions, position == pos)$y
print(x)
print(y)
setNodePositionBypass(ptm, x, y)
pos <- pos+1
}
ptms.all <- rbind(ptms.all, ptms)
}
##############
## Data viz
style.name = "WikiPathways"
loadTableData(cptac.protein,data.key.column="symbol", "node", table.key.column = 'shared name')
RCy3::setNodeColorMapping('CCRCC.pval', colors=paletteColorBrewerReds(), style.name = style.name)
RCy3::setNodeColorMapping('CCRCC.pval', colors=paletteColorBrewerReds(), style.name = style.name)
RCy3::setNodeColorMapping('CCRCC.pval', colors=paletteColorBrewerReds, style.name = style.name)
setNodeColorDefault('#FFFFFF', style.name = style.name)
setNodeBorderColorDefault("#737373", style.name = style.name)
## Update style for ptm nodes.
setNodeFontSizeBypass(ptms.all$SUID, 9)
setNodeWidthBypass(ptms.all$SUID, 40)
setNodeHeightBypass(ptms.all$SUID, 20)
## Define colors based on cutoffs.
ptms.all.data <- inner_join(ptms.all, matching.nodes.phospho, by = join_by(name == comp_id)) %>%
mutate(color = case_when(CCRCC.pval < 0.01 ~ "#FF0000", CCRCC.pval > 0.01 ~ "#F496AF"))
View(ptms.all.data)
View(ptms.all.data)
ptms.all.data.site <- ptms.all.data %>%
select(SUID, site) %>%
rename(name = site)
detach("package:plyr", unload = TRUE)
ptms.all.data.site <- ptms.all.data %>%
select(SUID, site) %>%
rename(name = site)
loadTableData(ptms.all.data.site,data.key.column="SUID", "node", table.key.column = "SUID")
setNodeColorBypass(node.names = ptms.all.data$SUID, new.colors = ptms.all.data$color)
###############
## Open and process WP, get relevant phospho data nodes and cross-check against kinase-substrate data
RCy3::commandsRun('wikipathways import-as-pathway id=WP4806')
## Remove existing ptm states from nodes. These are encoded as nodes with the label P.
selectNodes(nodes = "p", by.col = "name", preserve.current.selection = FALSE)
deleteSelectedNodes()
mode <- "all"
## Get all relevant protein/gene product data nodes in pathway
node.table <- RCy3::getTableColumns(table = "node")
node.table.prot <- subset(node.table, Type == 'Protein' | Type == 'GeneProduct') %>%
select(SUID, name, XrefId, Ensembl) ##get node table entries for relevant nodes
## All matching nodes: Intersection between pathway protein/gene nodes and phospho data
## These are the nodes we are going to add phospho nodes to
matching.nodes.prot <- node.table.prot %>%
filter(name %in% cptac.phospho.ccrcc.sig$symbol) %>%
select(SUID, name)
## Need this for matching with kinase substrate data
matching.nodes.phospho <- cptac.phospho.ccrcc.sig %>%
filter(symbol %in% node.table.prot$name) %>%
mutate(comp_id=paste0(symbol, "_", site)) %>%
select(symbol, site, comp_id, CCRCC.val, CCRCC.pval)
site.table <- matching.nodes.phospho
for (p in matching.nodes.prot$SUID){
prot <- matching.nodes.prot$name[matching.nodes.prot$SUID == p]
#Get node position for protein node
p.position <- getNodePosition(node.names = p)
#Calculate possible phospho site positions, limit to 4 sites for now.
phospho.positions <- data.frame()
pos.x <- p.position$x_location
pos.y <- p.position$y_location
##To-Do: update login to use node size(width/height)
phospho.positions <- data.frame(position=1:4, x=c(pos.x+40, pos.x+40, pos.x-40, pos.x-40), y=c(pos.y+10, pos.y-10, pos.y-10, pos.y+10))
#find relevant subset of cptac phospho data, these are the ptm nodes to add
phospho.nodes <- site.table %>%
filter(symbol == prot) %>%
select(comp_id)
print(phospho.nodes)
phospho.nodes <- head(phospho.nodes, 4) ##take first 4
##Add a node for each ptm, for the particular protein. Collect the SUID for the added ptm, and use it for updating position below.
suids <- addCyNodes(node.names = phospho.nodes$comp_id, skip.duplicate.names = FALSE)
ptms <- data.frame()
# ptms <- do.call(rbind, suids) doesnt work
for (l in suids){
ptms <- rbind(ptms, l)
}
##Set node position bypass for ptm nodes. Use 4 sites on each node.
pos <- 1
#for (ptm in phospho.nodes$comp_id){
for (ptm in ptms$SUID){
addCyEdges(c(p, ptm)) #need the SUID for this
x <- subset(phospho.positions, position == pos)$x
y <- subset(phospho.positions, position == pos)$y
print(x)
print(y)
setNodePositionBypass(ptm, x, y)
pos <- pos+1
}
ptms.all <- rbind(ptms.all, ptms)
}
for (p in matching.nodes.prot$SUID){
prot <- matching.nodes.prot$name[matching.nodes.prot$SUID == p]
#Get node position for protein node
p.position <- getNodePosition(node.names = p)
#Calculate possible phospho site positions, limit to 4 sites for now.
phospho.positions <- data.frame()
pos.x <- p.position$x_location
pos.y <- p.position$y_location
##To-Do: update login to use node size(width/height)
phospho.positions <- data.frame(position=1:4, x=c(pos.x+40, pos.x+40, pos.x-40, pos.x-40), y=c(pos.y+10, pos.y-10, pos.y-10, pos.y+10))
#find relevant subset of cptac phospho data, these are the ptm nodes to add
phospho.nodes <- site.table %>%
filter(symbol == prot) %>%
select(comp_id)
print(phospho.nodes)
phospho.nodes <- head(phospho.nodes, 4) ##take first 4
##Add a node for each ptm, for the particular protein. Collect the SUID for the added ptm, and use it for updating position below.
suids <- addCyNodes(node.names = phospho.nodes$comp_id, skip.duplicate.names = FALSE)
ptms <- data.frame()
# ptms <- do.call(rbind, suids) doesnt work
for (l in suids){
ptms <- rbind(ptms, l)
}
##Set node position bypass for ptm nodes. Use 4 sites on each node.
pos <- 1
#for (ptm in phospho.nodes$comp_id){
for (ptm in ptms$SUID){
addCyEdges(c(p, ptm)) #need the SUID for this
x <- subset(phospho.positions, position == pos)$x
y <- subset(phospho.positions, position == pos)$y
print(x)
print(y)
setNodePositionBypass(ptm, x, y)
pos <- pos+1
}
ptms.all <- rbind(ptms.all, ptms)
}
print(unique(matchin.nodes.prot$symbol))
print(unique(matching.nodes.prot$symbol))
print(unique(matching.nodes.prot$name))
###############
## Open and process WP, get relevant phospho data nodes and cross-check against kinase-substrate data
RCy3::commandsRun('wikipathways import-as-pathway id=WP4806')
## Remove existing ptm states from nodes. These are encoded as nodes with the label P.
selectNodes(nodes = "p", by.col = "name", preserve.current.selection = FALSE)
deleteSelectedNodes()
mode <- "all"
## Get all relevant protein/gene product data nodes in pathway
node.table <- RCy3::getTableColumns(table = "node")
node.table.prot <- subset(node.table, Type == 'Protein' | Type == 'GeneProduct') %>%
select(SUID, name, XrefId, Ensembl) ##get node table entries for relevant nodes
## All matching nodes: Intersection between pathway protein/gene nodes and phospho data
## These are the nodes we are going to add phospho nodes to
matching.nodes.prot <- node.table.prot %>%
filter(name %in% cptac.phospho.ccrcc.sig$symbol) %>%
select(SUID, name)
## Need this for matching with kinase substrate data
matching.nodes.phospho <- cptac.phospho.ccrcc.sig %>%
filter(symbol %in% node.table.prot$name) %>%
mutate(comp_id=paste0(symbol, "_", site)) %>%
select(symbol, site, comp_id, CCRCC.val, CCRCC.pval)
site.table <- matching.nodes.phospho
## If mode is "kinase only", update inputs
if (mode == "kinase"){
site.table <- phospho.psp.kin.sites
}
ptms.all <- data.frame()
for (p in matching.nodes.prot$SUID){
prot <- matching.nodes.prot$name[matching.nodes.prot$SUID == p]
#Get node position for protein node
p.position <- getNodePosition(node.names = p)
p.width <- getNodeWidth(node.names = p)
p.height <- getNodeHeight(node.names = p)
#Calculate possible phospho site positions, limit to 4 sites for now.
phospho.positions <- data.frame()
pos.x <- p.position$x_location
pos.y <- p.position$y_location
##To-Do: update login to use node size(width/height)
#phospho.positions <- data.frame(position=1:4, x=c(pos.x+40, pos.x+40, pos.x-40, pos.x-40), y=c(pos.y+10, pos.y-10, pos.y-10, pos.y+10))
phospho.positions <- data.frame(position=1:4, x=c(pos.x+(p.width/2)+20, pos.x+(p.width/2)+20, pos.x-+(p.width/2)-20, pos.x-(p.width/2)-20), y=c(pos.y+(p.height/2)+10, pos.y-(p.height/2)-10, pos.y-(p.height/2)-10, pos.y+(p.height/2)+10))
#find relevant subset of cptac phospho data, these are the ptm nodes to add
phospho.nodes <- site.table %>%
filter(symbol == prot) %>%
select(comp_id)
print(phospho.nodes)
phospho.nodes <- head(phospho.nodes, 4) ##take first 4
##Add a node for each ptm, for the particular protein. Collect the SUID for the added ptm, and use it for updating position below.
suids <- addCyNodes(node.names = phospho.nodes$comp_id, skip.duplicate.names = FALSE)
ptms <- data.frame()
# ptms <- do.call(rbind, suids) doesnt work
for (l in suids){
ptms <- rbind(ptms, l)
}
##Set node position bypass for ptm nodes. Use 4 sites on each node.
pos <- 1
#for (ptm in phospho.nodes$comp_id){
for (ptm in ptms$SUID){
addCyEdges(c(p, ptm)) #need the SUID for this
x <- subset(phospho.positions, position == pos)$x
y <- subset(phospho.positions, position == pos)$y
print(x)
print(y)
setNodePositionBypass(ptm, x, y)
pos <- pos+1
}
ptms.all <- rbind(ptms.all, ptms)
}
##############
## Data viz
style.name = "WikiPathways"
loadTableData(cptac.protein,data.key.column="symbol", "node", table.key.column = 'shared name')
RCy3::setNodeColorMapping('CCRCC.pval', colors=paletteColorBrewerReds, style.name = style.name)
setNodeColorDefault('#FFFFFF', style.name = style.name)
setNodeBorderColorDefault("#737373", style.name = style.name)
## Update style for ptm nodes.
setNodeFontSizeBypass(ptms.all$SUID, 9)
setNodeWidthBypass(ptms.all$SUID, 40)
setNodeHeightBypass(ptms.all$SUID, 20)
matching.nodes.prot <- node.table %>%
filter(name %in% cptac.phospho.ccrcc.sig$symbol) %>%
select(SUID, name)
View(matching.nodes.prot)
## Need this for matching with kinase substrate data
matching.nodes.phospho <- cptac.phospho.ccrcc.sig %>%
filter(symbol %in% node.table.prot$name) %>%
mutate(comp_id=paste0(symbol, "_", site)) %>%
select(symbol, site, comp_id, CCRCC.val, CCRCC.pval)
## Overlap between phospho nodes and kinase-substrate data, where the kinase (GENE) is on the pathway
phospho.psp.kin <- inner_join(matching.nodes.phospho, psp.data.human) %>%
filter(GENE %in% kinase.pw)
View(phospho.psp.kin)
## Overlap between phospho nodes and kinase-substrate data, where the kinase (GENE) is on the pathway
phospho.psp.kin <- inner_join(matching.nodes.phospho, psp.data.human) %>%
filter(GENE %in% kinase.pw) %>%
select(symbol, comp_id, site, CCRCC.val, CCRCC.pval)
###############
## Open and process WP, get relevant phospho data nodes and cross-check against kinase-substrate data
RCy3::commandsRun('wikipathways import-as-pathway id=WP4806')
## Remove existing ptm states from nodes. These are encoded as nodes with the label P.
selectNodes(nodes = "p", by.col = "name", preserve.current.selection = FALSE)
deleteSelectedNodes()
## Get all relevant protein/gene product data nodes in pathway
node.table <- RCy3::getTableColumns(table = "node")
node.table.prot <- subset(node.table, Type == 'Protein' | Type == 'GeneProduct') %>%
select(SUID, name, XrefId, Ensembl) ##get node table entries for relevant nodes. not sure we need this
## All matching nodes: Intersection between pathway protein/gene nodes and significant phospho data
## These are the nodes we are going to add phospho nodes to.
matching.nodes.prot <- node.table.prot %>%
filter(name %in% cptac.phospho.ccrcc.sig$symbol) %>%
select(SUID, name)
## Need this for matching with kinase substrate data
matching.nodes.phospho <- cptac.phospho.ccrcc.sig %>%
filter(symbol %in% node.table.prot$name) %>%
mutate(comp_id=paste0(symbol, "_", site)) %>%
select(symbol, site, comp_id, CCRCC.val, CCRCC.pval)
###############
## Only those sites with kinases on pathway: Subset of matching nodes with relevant kinases in the pathway
## To-Do: redo for SUID
kinase.pw <- intersect(psp.data.human$GENE, node.table.prot$name) #Kinases on pathway. GENE column contains kinase.
## Overlap between phospho nodes and kinase-substrate data, where the kinase (GENE) is on the pathway
phospho.psp.kin <- inner_join(matching.nodes.phospho, psp.data.human) %>%
filter(GENE %in% kinase.pw) %>%
select(symbol, comp_id, site, CCRCC.val, CCRCC.pval)
phospho.psp.kin.sites <- phospho.psp.kin %>%
select(symbol, comp_id, CCRCC.val, CCRCC.pval)
phospho.psp.kin.sites <- distinct(phospho.psp.kin.sites)
mode <- "kinase"
site.table <- matching.nodes.phospho
## If mode is "kinase only", update inputs
if (mode == "kinase"){
site.table <- phospho.psp.kin.sites
}
ptms.all <- data.frame()
overlap <- intersect(matching.nodes.prot$name, phospho.psp.kin$symbol)
for (p in matching.nodes.prot$SUID){
prot <- matching.nodes.prot$name[matching.nodes.prot$SUID == p]
#Get node position for protein node
p.position <- getNodePosition(node.names = p)
p.width <- getNodeWidth(node.names = p)
p.height <- getNodeHeight(node.names = p)
#Calculate possible phospho site positions, limit to 4 sites for now.
phospho.positions <- data.frame()
pos.x <- p.position$x_location
pos.y <- p.position$y_location
#phospho.positions <- data.frame(position=1:4, x=c(pos.x+40, pos.x+40, pos.x-40, pos.x-40), y=c(pos.y+10, pos.y-10, pos.y-10, pos.y+10))
phospho.positions <- data.frame(position=1:4, x=c(pos.x+(p.width/2)+18, pos.x+(p.width/2)+18, pos.x-+(p.width/2)-18, pos.x-(p.width/2)-18), y=c(pos.y+(p.height/2), pos.y-(p.height/2), pos.y-(p.height/2), pos.y+(p.height/2)))
#find relevant subset of cptac phospho data, these are the ptm nodes to add
phospho.nodes <- site.table %>%
filter(symbol == prot) %>%
select(comp_id)
phospho.nodes <- head(phospho.nodes, 4) ##take first 4
##Add a node for each ptm, for the particular protein. Collect the SUID for the added ptm, and use it for updating position below.
suids <- addCyNodes(node.names = phospho.nodes$comp_id, skip.duplicate.names = FALSE)
print("added nodes")
print(suids)
print("for")
print(prot)
ptms <- data.frame()
# ptms <- do.call(rbind, suids) #doesnt work
for (l in suids){
ptms <- rbind(ptms, l)
}
##Set node position bypass for ptm nodes. Use 4 sites on each node.
pos <- 1
#for (ptm in phospho.nodes$comp_id){
for (ptm in ptms$SUID){
addCyEdges(c(p, ptm)) #need the SUID for this
x <- subset(phospho.positions, position == pos)$x
y <- subset(phospho.positions, position == pos)$y
print(x)
print(y)
setNodePositionBypass(ptm, x, y)
pos <- pos+1
}
ptms.all <- rbind(ptms.all, ptms)
}
if(!"rWikiPathways" %in% installed.packages()){
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("rWikiPathways", update = FALSE)
}
library(rWikiPathways)
load.libs <- c(
"DOSE",
"GO.db",
"GSEABase",
"org.Hs.eg.db",
"clusterProfiler",
"dplyr",
"tidyr",
"ggplot2",
"stringr",
"RColorBrewer",
"rWikiPathways",
"RCy3")
options(install.packages.check.source = "no")
options(install.packages.compile.from.source = "never")
if (!require("pacman")) install.packages("pacman"); library(pacman)
p_load(load.libs, update = TRUE, character.only = TRUE)
status <- sapply(load.libs,require,character.only = TRUE)
if(all(status)){
print("SUCCESS: You have successfully installed and loaded all required libraries.")
} else{
cat("ERROR: One or more libraries failed to install correctly. Check the following list for FALSE cases and try again...\n\n")
status
}
cytoscapePing()  #this will tell you if you're able to successfully connect to Cytoscape or not
installApp('CyTargetLinker')
installApp('enrichmentMap')
lung.expr <- read.csv(system.file("extdata","data-lung-cancer.csv", package="rWikiPathways"),stringsAsFactors = FALSE)
nrow(lung.expr)
head(lung.expr)
up.genes <- lung.expr[lung.expr$log2FC > 1 & lung.expr$adj.P.Value < 0.05, 1]
dn.genes <- lung.expr[lung.expr$log2FC < -1 & lung.expr$adj.P.Value < 0.05, 1]
bkgd.genes <- lung.expr[,1]
up.genes.entrez <- clusterProfiler::bitr(up.genes,fromType = "ENSEMBL",toType = "ENTREZID",OrgDb = org.Hs.eg.db)
cat("\n\nWhich column contains my new Entrez IDs?\n")
head(up.genes.entrez)
keytypes(org.Hs.eg.db)
dn.genes.entrez <- bitr(dn.genes,fromType = "ENSEMBL",toType = "ENTREZID",OrgDb = org.Hs.eg.db)
bkgd.genes.entrez <- bitr(bkgd.genes,fromType = "ENSEMBL",toType = "ENTREZID",OrgDb = org.Hs.eg.db)
egobp <- clusterProfiler::enrichGO(
gene     = up.genes.entrez[[2]],
universe = bkgd.genes.entrez[[2]],
OrgDb    = org.Hs.eg.db,
ont      = "BP",
pAdjustMethod = "fdr",
pvalueCutoff = 0.05, #p.adjust cutoff (https://github.com/GuangchuangYu/clusterProfiler/issues/104)
readable = TRUE)
head(egobp,10)
barplot(egobp, showCategory = 20)
# extract a dataframe with results from object of type enrichResult
egobp.results.df <- egobp@result
## create a new column for term size from BgRatio
egobp.results.df$term.size <- gsub("/(\\d+)", "", egobp.results.df$BgRatio)
## filter for term size to keep only term.size => 3, gene count >= 5 and subset
egobp.results.df <- egobp.results.df[which(egobp.results.df[,'term.size'] >= 3 & egobp.results.df[,'Count'] >= 5),]
egobp.results.df <- egobp.results.df[c("ID", "Description", "pvalue", "qvalue", "geneID")]
## format gene list column
egobp.results.df$geneID <- gsub("/", ",", egobp.results.df$geneID)
## add column for phenotype
egobp.results.df <- cbind(egobp.results.df, phenotype=1)
egobp.results.df <- egobp.results.df[, c(1, 2, 3, 4, 6, 5)]
## change column headers
colnames(egobp.results.df) <- c("Name","Description", "pvalue","qvalue","phenotype", "genes")
egobp.results.filename <-file.path(getwd(),paste("clusterprofiler_cluster_enr_results.txt",sep="_"))
write.table(egobp.results.df,egobp.results.filename,col.name=TRUE,sep="\t",row.names=FALSE,quote=FALSE)
em_command = paste('enrichmentmap build analysisType="generic" ',
'pvalue=',"0.05", 'qvalue=',"0.05",
'similaritycutoff=',"0.25",
'coeffecients=',"JACCARD",
'enrichmentsDataset1=',egobp.results.filename ,
sep=" ")
#enrichment map command will return the suid of newly created network.
em_network_suid <- commandsRun(em_command)
renameNetwork("Cluster1_enrichmentmap_cp", network=as.numeric(em_network_suid))
ewp.up <- clusterProfiler::enrichWP(
up.genes.entrez[[2]],
universe = bkgd.genes.entrez[[2]],
organism = "Homo sapiens",
pAdjustMethod = "fdr",
pvalueCutoff = 0.1, #p.adjust cutoff; relaxed for demo purposes
)
head(ewp.up)
dotplot(egobp, showCategory = 20)
goplot(egobp)
load.libs <- c(
"DOSE",
"GO.db",
"GSEABase",
"org.Hs.eg.db",
"clusterProfiler",
"dplyr",
"tidyr",
"ggplot2",
"stringr",
"RColorBrewer",
"rWikiPathways",
"RCy3")
if(!require(devtools)) install.packages("devtools"); library(devtools)
options(shiny.launch.browser = .rs.invokeShinyWindowExternal)
source_url("https://raw.github.com/gladstone-institutes/Interactive-Enrichment-Analysis/main/launch_app.R")
